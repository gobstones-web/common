<dom-module id="dom-repeat-n">
  <template>
    <style>
      
    </style>


  </template>
  <script>
    Polymer({
      is: 'dom-repeat-n',
      "extends": 'template',
      _template: null,
      properties: {
        count: {
          type: Number,
          value: 0,
          observer: '_countChanged'
        },
        start: {
          type: Number,
          value: 0,
          observer: '_startChanged'
        },
        increment: {
          type: Number,
          value: 1,
          observer: '_incrementChanged'
        },
        indexAs: {
          type: String,
          value: 'index'
        }
      },
      behaviors: [Polymer.Templatizer],
      created: function() {
        this._instances = [];
        this._pool = [];
      },
      ready: function() {
        this._instanceProps = {};
        this._instanceProps[this.indexAs] = true;
        if (!this.ctor) {
          this.templatize(this);
        }
      },
      attached: function() {
        var i, parent;
        parent = Polymer.dom(Polymer.dom(this).parentNode);
        i = 0;
        while (i < this._instances.length) {
          this._attachInstance(i, parent);
          i++;
        }
      },
      detached: function() {
        var i;
        i = 0;
        while (i < this._instances.length) {
          this._detachInstance(i);
          i++;
        }
      },
      _countChanged: function(newCount, oldCount) {
        if (isNaN(newCount)) {
          this.count = oldCount;
          console.error('dom-repeat-n: count should be a number');
          return;
        }
        if (typeof newCount !== 'number') {
          newCount = parseInt(newCount);
        }
        if (newCount < 0) {
          this.count = oldCount;
          console.error('dom-repeat-n: count cannot be negative');
          return;
        }
        this.async(function() {
          var i, inst, limit;
          i = void 0;
          i = 0;
          while (i < newCount) {
            inst = this._instances[i];
            if (!inst) {
              inst = this._insertInstance(i);
            }
            i++;
          }
          limit = this._instances.length;
          i = newCount;
          while (i < limit) {
            this._detachAndRemoveInstance(i);
            i++;
          }
          this._debounceTemplate(this._render);
          this.fire('dom-change');
        });
      },
      _startChanged: function(newStart, oldStart) {
        if (typeof newStart !== 'number') {
          this.start = oldStart;
          console.error('dom-repeat-n: start should be a number');
          return;
        }
        this._debounceTemplate(this._render);
      },
      _incrementChanged: function(newIncrement, oldIncrement) {
        if (typeof newIncrement !== 'number') {
          this.increment = oldIncrement;
          console.error('dom-repeat-n: start should be a number');
          return;
        }
        this._debounceTemplate(this._render);
      },
      _render: function() {
        var i, inst;
        i = 0;
        while (i < this.count) {
          inst = this._instances[i];
          inst.__setProperty(this.indexAs, i * this.increment + this.start, true);
          i++;
        }
      },
      _attachInstance: function(idx, parent) {
        var inst;
        inst = this._instances[idx];
        parent.insertBefore(inst.root, this);
      },
      _detachInstance: function(idx) {
        var el, i, inst;
        inst = this._instances[idx];
        i = 0;
        while (i < inst._children.length) {
          el = inst._children[i];
          Polymer.dom(inst.root).appendChild(el);
          i++;
        }
        return inst;
      },
      _detachAndRemoveInstance: function(idx) {
        var inst;
        inst = this._detachInstance(idx);
        if (inst) {
          this._pool.push(inst);
        }
        this._instances.splice(idx, 1);
      },
      _stampInstance: function(idx) {
        var model;
        model = {};
        model[this.indexAs] = idx;
        return this.stamp(model);
      },
      _insertInstance: function(idx) {
        var beforeNode, beforeRow, inst, parentNode;
        inst = this._pool.pop();
        if (!inst) {
          inst = this._stampInstance(idx);
        }
        beforeRow = this._instances[idx + 1];
        beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
        parentNode = Polymer.dom(this).parentNode;
        Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
        this._instances.push(inst);
        return inst;
      },
      _showHideChildren: function(hidden) {
        var i;
        i = 0;
        while (i < this._instances.length) {
          this._instances[i]._showHideChildren(hidden);
          i++;
        }
      }
    });

  </script>
</dom-module>